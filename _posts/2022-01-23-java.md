---
title: Java
author: 강지우
date: 2022-01-23
category: java
layout: post
---

# 1. 자바 언어의 이해  
본래의  개발 취지는 가전제품에 탑재될 소프트웨어를 만들기 위해서였고, 처음엔 c++을 확장해 사용하려고 하였지만 부족함을 느끼고 **c++의 장점을 도입하고 단점을 보완**한 새로운 언어로 개발되었다.  
1. 자바  
    1. 자바는 썬에서 개발한 객체지향 언어이다. 가정용 단말기에 적용하려는 목적으로 오크언어에서 비롯되었다.  
    2. 오크는 상품화되지 못했지만, 인터넷이 발전하면서 인터넷 친화적인 개발언어로 전환해 자바라는 이름으로 새롭게 소개되었다.  
    3. 현재 자바는 IT기술 전반에서 가장 널리 사용하는 프로그래밍 언어가 되었다.  
2. 장점  
    1. 간결하면서도 강력한 객체지향 언어이다.
    2. 개방형 구조로 여러 기술과 융합이 가능하다.  
    3. 플랫폼에 독립적이므로, 여러 운영체제나 하드웨어에서도 동일하게 실행한다.  
    4. 많은 오픈소스 프레임워크로 생산성을 증가하고 유지보수 비용을 절감할 수 있다.  
3. 단점  
    1. 처리 속도가 중요한 애플리케이션에는 적합하지 않다.  
    . GUI요소가 많은 MS 위도우 응용 프로그램 개발에는 적합하지 않다.  
    3. 하드웨어에 연결하여 제어할 수 없기 때문에(가상머신 이용) 직접 하드웨어를 정밀하게 조정해야 하는 프로그램 개발에는 적합하지 않다.  

# 2. 기초 문법  
## 1. 변수  
### 1. 변수란?  
프로그래밍 언어에서의 변수란 값을 저장할 수 있는 메모리 상의 공간을 의미한다.  
하나의 변수에 단 하나의 값만 저장할 수 있으므로, 새로운 값을 저장하면 기본값은 사라진다.
#### 1. 변수의 선언과 초기화
변수를 선언하는 방법 : ```int age;//변수타입이 정수(int)인 age라는 이름의 변수를 선언.  ```  
변수타입은 변수에 저장될 값이 어떤 타입인지를 지정하는 것이다. 자바는 정수형, 실수형, 문자형 등 다양한 타입을 지원한다.  
변수이름은 메모리 공간에 이름을 붙여주는 것이다. 이름을 이용해 저장공간에 저장하고, 저장된 값을 불러올 수 있다.  
변수를 선언한 후 변수를 사용할 수 있지만, 그전 변수를 반드시 초기화 해야한다. 메모리는 여러 프로그램이 공유하는 자원이므로 다른 프로그램에 의해 저장된 알 수 없는 값(쓰레기값)이 남아있을 수도 있기 때문이다.  
변수에 값을 저장할 때에는 대입연산자 `=`를 이용한다. 오른쪽 값을 왼쪽(변수)에 저장한다.  
>"변수의 초기화란, 변수를 사용하기 전에 처음으로 값을 지정하는 것"  

#### 2. 변수의 명명규칙
프로그래밍에서 사용하는 모든 이름을 식별자라고 하며, 같은 영역 내에서 서로 구분될 수 있어야 한다.  
1. 대소문자가 구분되며 길이에 제한이 없다. true와 True는 서로 다른것으로 간주한다.  
2. 예약어를 사용해서는 안된다. true는 예약어라서 사용이 불가 하지만, True는 가능하다.  
3. 숫자로 시작해선 안된다. top10은 가능하지만 10top은 불가능하다.   
4. 특수문자는 ‘_’와 ‘$’만을 허용  
변수의 이름은 짧을수록 좋지만 약간 길더라도 용도를 알기 쉽게 ‘의미있는 이름’으로 하는것이 바람직하다.  

### 2.  변수의 타입  
#### 1. 기본형  
변수의 타입은 기본형과 참조형이 있다.  
기본형 변수는 실제 값을 저장  
+ 논리형, 문자형, 정수형, 실수형  
+ 계산을 위한 실제 값을 저장한다.  
참조형 변수는 어떤 값이 저장되어 있는 주소 값을 가짐  
+ 객체의 주소를 저장한다. 기본형을 제외한 나머지 타입.  
+ c언어와 달리 참조형 변수 간의 연산을 할 수 있다.  
+ 참조형 변수를 선언할 때에 변수의 타입으로 클래스의 이름을 사용하면 클래스의 이름이 참조변수의 타입이 된다.  
+ 참조형 변수의 선언방법 : ```클래스이름 변수이름; ```
##### 1. 논리형 - **boolean**
true와 false 중 하나를 저장할 수 있으며 기본값은 false이다. boolean형 변수는 대답, 스위치 등의 논리구현에 주로 사용된다.  
참 거짓 두가지의 값만 표현하면 되기 때문에 1bit면 충분하지만 자바에서는 데이터를 다루는 최소단위가 1byte이기 때문에 boolean의 크기는 1byte이다.  
주의 - TRUE와 true는 다르게 간주
##### 2. 문자형 - **char**  
char 타입의 변수는 단 하나의 문자만을 저장할 수 있다. 변수에 문자가 저장되는것 같지만, 문자가 아닌 유니코드가 저장된다.  
문자 리터럴 대신 문자의 유니코드 설정 가능하다. ‘A’의 유니코드가 65이고 , 변수 선언할때 유니코드로 선언 가능하다.  
char 타입의 크기는 2byte이다.  
    tab: \t  
    backspace: \b  
    form feed: \f  
    new line: \n  
    caffiage return: \r  
    역슬래쉬(\):\\  
    작은 따옴표: \'  
    큰 따옴표: \"   

##### 3. 정수형 - **byte, short, int, long**  
byte (1 byte) < short (2 byte) < int (4 byte)< long (8 byte)  
어떤 진법의 리터럴을 변수에 저장해도 실제로는 2진수로 바뀌어 저장된다.  
크게는 정수형과 실수형이 있다. 정수형 변수를 선언할 때에는 int 타입으로 하고, int의 범위가 넘어서는 큰 수를 다뤄야 한다면 long을 사용하면 된다. 
##### 4. 실수형 - **float, double**  
float - 소수 7자리 수 까지 출력, 4byte  
double - 소수 15자리 수 까지 출력, 8byte  
실수형은 얼마나 큰 값을 표현할 수 있는지도 중요하고, 얼마나 0에 가깝게 표현할 수 있는지도 중요하다. 그렇기 때문에 소수 7자리 이상의 정밀도가 필요하다면, 변수의 타입을 double로 해야한다.  
실수형은 정수형과 표현방식이 달라서, 실수형은 부동소수점수의 형태로 저장된다.  

#### 2. 상수와 리터럴  
**상수**  
변수와 마찬가지로 저장할 수 있는 공간이지만 변수와 달리 한번 값을 지정하고 나면 다른 값으로 변경할 수 없다.  
상수를 선언하는 방법 : ``` final int Max_SPEED = 10;```  
상수는 선언과 동시에 초기화를 해줘야한다. 상수의 이름은 모두 대문자로 하는게 암묵적 관례이다.  
**리터럴**  
프로그래밍에서 상수를 '값을 한번 저장하면 변경할 수 없는 저장공간'으로 정의하였기 때문에 이와 구별하기 위해 리터럴로 부른다.  
**변수(variable)** : 하나의 값을 저장하기 위한 공간  
**상수(constant)** : 값을 한번만 저장할 수 있는 공간  
**리터럴(literal)** : 그 자체로 값을 의미하는 것  
```java 
int year = 2022; // 변수 2022, 리터럴 100, MAX_VALUE는 상수
final int MAX_VALUE = 100;
```
#### 3. 출력과 입력  
**출력**  
print: 괄호안 내용을 단순히 출력. 줄바꿈문자(\n) 포함안됨.  
printf: %d, %s 등을 쓰기 위해 사용. 줄바꿈 문자 포함안됨.  
println: 개행문자가 포함되어 있어 출력후 띄어짐.  

    %b: boolean형식으로 출력  
    %d: 10진 정수의 형식으로 출력  
    %o: 8진 정수의 형식으로 출력  
    %x,%X: 16진 정수의 형식으로 출력  
    %f: 부동 소수점의 형식으로 출력  
    %c: 문자로 출력  
    %s: 문자열로 출력  

**입력**  
scanner클래스는 정수, 실수, 문자열을 읽는다.  
```java 
import java.util.Scanner; //를 이용해서 호출  
Scanner sc = new Scanner(System.in);
```
객체를 생성해야지만 사용가능한 클래스이다.  
특정 데이터 유형의 값을 읽기 위해 사용하는 함수는 next~()이다.  
scan.close()로 종료할 수 있다.  
``` java
public static void main(String[]args){
    int a;
    Scanner sc =new Scanner(System.in);
    System.out.println("숫자");
    a=sc.nextInt();
    System.out.println(a);
}
```  
숫자하나를 입력받아 해당 숫자 단의 구구단을 출력  
```java
public static void main(String[]args) {
    System.out.println("정수 하나를 입력하시오");
    int n;
    Scanner sc = new Scanner(System.in);
    n = sc.nextInt();
    int i;
    for (i = 1; i < 10; i++) {
            System.out.println(i * n);
    }
}
```  

### 3. 형변환  
#### 1. 형변환(캐스팅)이란?  
모든 변수와 리터럴에는 타입이 있다. 서로 다른 타입간의 연산을 수행해야 할 때에 필요한 것이 형변환이다.  
> 형변환이란, 변수 또는 상수의 타입을 다른 타입으로 변환하는것  

#### 2. 형변환 방법
(타입)피연산자 / ()는 캐스트 연산자, 형변환 연산자  
``` java 
double b= 85.4;
int score=(int)d;//double타입의 변수 d를 int타입으로 형변환
int score(int)85.4;//변수 d의 값을 읽어서 형변환한다.
int score= 85;//형변환의 결과인 85를 score에 저장한다.
```  
형변환 연산자는 그저 피연산자의 값을 읽어서 지정된 타입으로 형변환하고 그 결과를 반환한다. 변수 d의 값은 형변환 후에도 달라 지지 않는다.  
기본형에서 boolean을 제외한 나머지 타입들은 서로 형변환이 가능하다. 기본형과 참조형 간의 형변환은 불가능하다.  
    int -> char : (char)65 -> 'A'  
    char -> int : (int)'A' -> 65  
    float -> int : (int)1.6f -> 1  
    int -> float : (float)10 -> 10.0f  
    float -> int로 형변환을 할때엔 반올림이 아닌 버림으로 처리된다.  
#### 3. 정수형간의 형변환  
큰 타입에서 작은 타입으로 변환하면 크기의 차이만큼 잘려 나간다. 그 경우 값 손실이 일어날 수도 있다.  
작은 타입에서 큰 타입으로 변환하면 값 손실이 일어나지는 않지만 나머지 빈공간은 0과 1로 채워진다.  
원래의 값을 채우고 0으로 채우는게 보통이지만, 변환 하려는 값이 음수일때엔 빈공간을 1로 채운다.  이유는 형변환 이후에도 부호를 유지하기 위해서이다.  
#### 4. 자동 형변환  
서로 다른 타입간의 대입이나 연산을 할때에 형변환으로 타입을 일치시켜 주는게 원칙이나, 편의상의 이유로 생략할 수도 있다.  
형변환이 이루어지지 않는것은 아니고 컴파일러가 생략된 형변환을 자동적으로 추가한다.  
```java 
float f = 1234;//형변환의 생략 
float f = (float)1234;//와 같음
``` 
이럴때엔 오류가 나타나지 않는다. 하지만 변수가 저장할 수 있는 값의 범위보다 더 큰 값을 저장하려는 경우 형변환을 생략하면 에러가 발생한다.  

**자동 형변환의 규칙**  
형변환을 하는 이유는 서로 다른 타입을 일치시키기 위한 것인데, 형변환을 생략하면 컴파일러가 알아서 형변환을 한다.  
**컴파일러의 판단기준**  
1. blooean을 제외한 나머지 7개의 기본형은 서로 형변환이 가능하다.  
2. 기본형과 참조형은 서로 형변환 할 수 없다.  
3. 서로 다른 타입의 변수간의 연산은 형변환을 하는 것이 원칙이지만, 값의 범위가 작은 타입에서 큰 타입으로의 형변환은 생략할 수 있다.  

## 2. 연산자  
### 1. 연산자의 종류
#### 1. 단항 연산자
**+, -, ~, !**  
피연산자가 오직 하나만 필요한 연산자이다.  
!: 현재 논리값을 부정  
~: 부정 연산자이며, 피연산자를 int형으로 변화시키고 부정한다.  
**증감 연산자**: ++, --  
피연산자로는 정수와 실수를 사용할 수 있다. 상수는 값을 변경할 수 없기 때문에 불가능하다. 다른 연산자들과 다르게 피연산자의 값을 변경하는 것이 가능하다.  
**증가 연산자(++)**: 피연산자의 값을 1 증가시킨다.  
**감소 연산자(--)**: 피연산자의 값을 1 감소시킨다.  
증감 연산자는 피연산자의 양쪽 모두에 위치할 수 있다.  

전위형 (왼쪽 위치): 값이 참조되기 **전** 증가시킨다.  
후위형 (오른쪽 위치): 값이 참조된 **후** 증가시킨다.  
증감 연산자가 수식이나 메소드 호출에 포함되지 않고 독립적으로 하나의 문장으로 쓰인 경우엔 차이 없다.  
#### 2. 이항 연산자
1. 산술 연산자  
**+, -, *, /, %**  
기본적인 사칙연산을 수행한다. %는 나눈 나머지값을 가진다.  
2. 비교(관계) 연산자  
**대소 비교 연산자**: >, >=, <, <=  
**등가 비교 연산자**: ==(같으면 참), !=(다르면 참)  
문자열의 비교  
두 문자열의 내용을 비교할 때엔 비교 연산자 '==' 대신 equals()라는 메소드를 사용해야한다.  
```java
public class Ex1 {
    public static void main (String[]args) {
    String s1 = "asd";
    String s2 = new String("asd");
        if (s1.equals(s2)) {
            System.out.println("참");
        }
        else {
            System.out.println("거짓");
        }
    }
}//결과: 참
        if (s1==s2) {
            System.out.println("참");
        }
        else {
            System.out.println("거짓");
        } // 결과: 거짓
```
'=='로 비교한 두개의 값은 서로 다르다고 나온다. '=='의 경우 타입의 변수 값은 객체 주소이기 때문에 주소값을 비교해 다르다는 결론이 나온 것이다.  
3. 논리 연산자  
**&&, ||**  
**&&**: 두 피연산자의 값이 모두 참일때 참을 반환한다.  
**||**: 두 피연산자의 값들 중 하나라도 참일때 참을 반환한다.  
**비트 연산자**: &, ^, |  
**&**: 두개의 피연산자가 모두 1이여야 결과값 1 얻는다. 아닐경우 결과값 0을 얻는다.  
**|**: 두개의 피연산자 중 하나의 피연산자 값이 1이면 결과값 1을 얻는다.  
**^**: 두개의 피연산자 값이 서로 다를때만  결과값 1을 얻는다. 같을경우 결과값 0을 얻는다.  
```java
import java.util.Scanner;
public class Ex1 {
    public static void main (String[]args) {
        Scanner sc = new Scanner(System.in);
        char ch = ' ';
        System.out.printf("문자하나를 입력하세요");
        String input=sc.nextLine();
        ch=input.charAt(0);

        if('0'<=ch&&ch<='0'){
            System.out.println("입력하신 문자는 숫자입니다");
        }
        if(('a'<=ch&&ch<='z')||('A'<=ch&&ch<='Z')){
            System.out.println("입력하신 문자는 영문자입니다");
       }
    }
} //결과: 숫자 입력시 숫자입니다 출력. 영문자 입력시 영문자입니다 출력 
```  

#### 3. 삼항 연산자
**?, :**  
조건항?항1:항2의 구조로 조건항이 참일 경우 항1의 값을 반환하고, 거짓일 경우 항2의 값을 반환한다.  

#### 4. 대입 연산자
**=**  
우변의 값을 좌변에 저장한다.  

### 2. 연산자의 우선순위
괄호의 우선순위가 가장 높고, **산술>비교>논리>대입**의 순서이며, **단항>이항>삼항**의 순서이다.  
연산자의 연산 진행방법은 **왼쪽에서 오른쪽**으로 수행되며, **단항 연산자와 대입 연산자의 경우 오른쪽에서 왼쪽**으로 수행한다.  
|우선순위|연산자|내용|  
|:-:|:------------:|:-----------------:|  
|1  |(),[]         |괄호, 대괄호          |  
|2  |!, ~, ++, --  |부정, 증감 연산자      |  
|3  |*, /, %       |곱셈, 나눗셈 연산자     |  
|4  |+, -          |덧셈, 뺄셈 연산자      |  
|5  |<<, >>, >>>   |비트단위의 쉬프트 연산자 |  
|6  |<, <=, >, >=  |관계 연산자           |  
|7  |==, =!        ||  
|8  |&             |비트단위의 논리 연산자|  
|9  |^             ||  
|10 |\|            ||  
|11 |&&            |논리곱 연산자|  
|12 |\|\|          |논리합 연산자|  
|13 |?:            |조건 연산자|  
|14 |=, +=, -=,,,  |대입, 할당 연산자|  
### 3. 연산자의 결합규칙
연산자의 연산 진행방법은 **왼쪽에서 오른쪽**으로 수행되며, **단항 연산자와 대입 연산자의 경우 오른쪽에서 왼쪽**으로 수행한다.  
>1) 산술 > 비교 > 논리 > 대입. 대입은 가장 마지막에 수행  
>2) 단항(1) > 이항(2) > 삼항(3). 단항 연산자의 우선순위가 이항 연산자보다 높다.  
>3) 단항 연산자와 대입 연산자를 제외한 모든 연산의 진행방향은 왼쪽에서 오른쪽이다.  

### 4. 산술 변환 
이항 연산자는 두 피연산자의 타입이 일치해야 연산이 가능하므로, 타입이 일치하지 않다면, 연산 전에 형변환 연산자로 타입을 일치시켜야 한다.  
```java
int i=10;
float f = 20.0f;
float result = f + (float)i;  //형변환으로 두 피연산자의 타입을 일치
float result = f+i; //더 큰 타입으로 일치 시킬때 자동 형변환
```  

형변환을 할때, 두 피연산자의 타입 중 더 큰 타입으로 일치시키는데, 그때엔 자동적으로 형변환되므로 형변환 연산자를 생략할 수 있다.  
>**산술 평균이란, 연산 수행 직전에 발생하는 피연산자의 자동 형변환**  
>두 피연산자의 타입을 같게 일치시킨다.(보다 더 큰 타입으로 일치)  
>피연산자의 타입이 int보다 작은 타입이면 int로 변환된다.  
